# 予約リードタイム分析ページ 構想メモ（2025-10-09）

## 目的

予約受付時刻から実際の受診予定時刻までの時間差（リードタイム）を可視化し、以下の仮説検証を行いやすくする。

- 「朝に予約した患者はその日のうちに受診するケースが多いか」
- 「診療科ごとに予約から受診までの平均待機時間が異なるか」
- 「短期予約と長期予約の比率を把握したい」

既存の `/reservations` ページへ機能追加すると負荷が高まるため、専用ページを新設して軽量化と集中した分析体験を両立する。

## ページパス案

- `src/app/reservations/leadtime/page.tsx`
- グローバルナビには「リードタイム分析」を追加（必要に応じて表示順を調整）

## 集計仕様

### 基本指標

1. **リードタイム（生の時間）**  
   `diffMs = appointmentIso - receivedAtIso`
   - 当日内の予約は `diffHours = diffMs / (1000 * 60 * 60)` を小数第一位まで表示
   - マイナス値（受診時刻が不明・過去）は除外

2. **カテゴリ分類（翌日以降）**
   - 翌日（24h <= diff < 48h）
   - 3日以内（diff < 72h）
   - 1週間以内（diff < 168h）
   - 2週間以内（diff < 336h）
   - それ以降（diff >= 336h）
   - 当日以内（diff < 24h）は別処理として時間単位集計

3. **グルーピング軸**
   - 予約受付時間帯（0〜23時）
   - 診療科
   - 初診 / 再診（余力があればトグル切り替え）
   - 期間・月フィルターは既存ページのロジックを再利用

### 集計ロジック案

`aggregateLeadtimeMetrics(reservations: Reservation[])` を実装し、以下を返却。

| フィールド     | 内容                                                                  |
| -------------- | --------------------------------------------------------------------- |
| `summary`      | 全体平均（hours）、中央値、P90、当日内割合、カテゴリ比率              |
| `byHour`       | 24要素の配列。各時間帯の予約数、平均時間、当日内割合、最頻カテゴリ等  |
| `byDepartment` | 診療科ごとの平均時間、中央値、カテゴリ比率、当日内割合                |
| `distribution` | ヒストグラム用途に生の時間差（hours）配列を保持（必要なら遅延ロード） |
| `totals`       | 該当件数、除外件数などのメタ情報                                      |

計算は1パスで完了するよう意識し、Map や固定長配列を用いて高速化。

## UI 構成（初稿）

1. **ヘッダー**
   - ページ説明文
   - 最終更新 / データ読み込み状態の表示（既存ページと統一感を保つ）

2. **フィルターセクション**
   - 期間セレクター、月セレクター、（オプション）初再診トグル、診療科ドロップダウン
   - 診療科フィルターは「全体 / 各科」選択時に `byDepartment` から該当情報のみ抽出

3. **サマリーカード**
   - 平均リードタイム（h）
   - 中央値（h）
   - 当日完了率（%）
   - 直前（24h以内）予約数

4. **予約時間帯 × リードタイム表 / グラフ**
   - 行：予約受付時間帯（0〜23時）
   - 列：平均時間、当日以内割合、最頻カテゴリ
   - グラフ版（必要に応じて `Bar` または `StackedBar`）は Lazy Load で表示ボタン式にする

5. **診療科別サマリー表**
   - 平均時間、中央値、当日内割合、カテゴリ比率（ヒートマップ風にするのも検討）

6. **カテゴリ分布ビジュアル**
   - ドーナツチャートまたは棒グラフでリードタイムカテゴリ比率を表示
   - こちらも Lazy Load で初期レンダリング負荷を低減

## 共有データへの組み込み

- `SharedDataBundle` に `leadtimeMetrics` を追加
  ```ts
  type SharedDataBundle = {
    reservations?: Reservation[];
    reservationsTimestamp?: string;
    leadtimeMetrics?: LeadtimeMetricsPayload;
    /* 既存フィールド */
  };
  ```
- 共有URL生成時にリードタイム集計をキャプチャし JSON 化。受信側で `applySharedPayload` が読み込み次第、`leadtimeMetrics` をローカルストレージへ同期。
- ファイル容量増を抑えるため、生データ配列は必要最低限（ヒストグラム用に最大1000件など上限を設ける）とする。

## 実装ステップ（ドラフト）

1. **ドメインモジュール**
   - `src/lib/leadtimeMetrics.ts`（仮）を新設し、集計ロジックと型定義を実装。
   - 既存の `aggregateReservationInsights` を参考にパフォーマンス最適化。
2. **ページ作成**
   - `src/app/reservations/leadtime/page.tsx` を追加。
   - フィルタリングロジックは `/reservations/page.tsx` の共通関数を可能な限り再利用。
3. **共有ロジック更新**
   - `dataShare` と `sharedBundle` の型を更新し、リードタイム集計を含める。
4. **UI コンポーネント**
   - 表セクションはまずテーブルで実装。パフォーマンスに余裕があれば Chart.js を後付け。
   - グラフは `WeekdayChartSection` 同様に Lazy Load。
5. **ナビゲーション更新**
   - `src/components/Navigation.tsx` に新規リンクを追加。
6. **テスト・検証**
   - 大きめの CSV でロード時間を計測。
   - 共有URL生成→別タブ読み込みで leadtime ページが同じデータを再現できるか確認。

## 未決事項・確認事項

- 初診/再診トグルは初回実装で含めるかオプションにするか。
- 分析対象データに appointmentIso が欠損している場合の取り扱い（除外、または「予約日時未設定」カテゴリを設ける）。
- グラフの有無・種類について最終的な UI 指示が必要か。

以上の方針で詳細設計・実装へ移る準備が整いました。追加要望があれば追記します。
